% !TEX encoding = UTF-8
% !TEX TS-program = pdflatex
% !TEX root = ../tesi.tex

%**************************************************************
\chapter{Progettazione e codifica}
\label{cap:progettazione e codifica}
%**************************************************************

\intro{In questo capitolo vengono trattati la progettazione e codifica della parte front-end della web-app. Vengono elencati e descritti tutti i componenti della web-app e la loro funzionalità.}\\

\section{Progettazione}
\subsection{Architettura Angular}
Un'applicazione Angular è formata da un insieme di moduli, dove il modulo pricinpale è il modulo root, chiamato AppModule, che contiene più moduli di funzionalità. Un modulo di funzionalità è composto da un componente, che definisce la vista dell'utente.\\
Ogni componente possiede un template di HTML, dove viene definita il modello di vista, quando un utente effettua un click su un bottone, questo elemento HTML emette un evento di click al componente in cui si trova, questo componente esegue il metodo specifico al evento ricevuto, di seuito viene cambiato il metadata e modificato il codice HTML, una volta cambiata la struttura della pagina viene fatto il rendering della pagina e viene cambiata la vista dell'utente.\\
% Quindi un click su un bottone questo elemento HTML emette un evento di click al componente in cui si trova, questo componente esegue il metodo specifico al evento ricevuto, di seuito viene cambiato il metadata e viene aggiornato il template di HTML.\\
I componenti utilizzano dei servizi che forniscono funzionalità specifiche come il login di Auth.Service, ma non sono correlate direttamente alla vista, essi sono inseriti come delle dipendenze e grazie a questo rende il codice efficiente. Non solo i servizi sono riutilizzabili ma anche i componenti lo sono, dunque rende l'applicazione Angular più semplice da comprendere e manutenibile in futuro.\\
\begin{figure}[H]
    \centering
    \includegraphics[scale=0.5]{angularArc.png}
    \caption{Architettura Angular}
\end{figure}
\subsection{Architettura SushiLab}
La web-app segue l'architettura spiegata precedentemente che è anche quello consigliato dal sito ufficiale di Angular.\\
La cartella principale della web-app è app che contiene tutti i componenti, i servizi e il root.\\ 
Per ogni componente si è creato una cartella per essa, in cui contiene il suoi file .ts per la logica, .html per la struttura, .scss per il layout di grafica e infine i suoi componenti figli. Per i componenti condivisi si è creato una cartella shared dove vengono salvati i componenti che sono utilizzati in più parti dell'applicazione.\\
Nella cartella \gls{restg} vengono salvati tutti i file service, in cui ci sono dei metodi che vengono chiamati in più componenti dell'applicazione al fine di massimizzare il riuso del codice.\\
Nella cartella assets vengono salvati le immagini e le icone utilizzate, in modo da fare utilizzare da tutti i componenti.\\
\begin{figure}[H]
    \centering
    \includegraphics[scale=0.55]{struttura.png}
    \includegraphics[scale=0.6]{struttura1.png}
    \includegraphics[scale=0.55]{struttura2.png}
    \caption{Struttura file SushiLab}
\end{figure}
\subsection{Progettazione delle viste}
All'inizio si è fatto un meeting con il tutor aziendale per chiarire le funzionalità e i requisiti che la web-app deve avere, dopo di che si è iniziato la progettazione dei mock-up delle viste tramite la editor di grafica online Figma.\\
Tramite il sistema di progettazione di Figma sono stati creati le bozze delle viste per chiarire i collegamenti tra di loro e i posizionamenti dei compoenti. 
Il posizionamento è scelto in base alla frequenza di click su di essa e si basa anche sulle viste dei web-app più popolari.
È stato deciso i seguenti aspetti:
\begin{itemize}
    \item I colori principali e lo sfondo della applicazione;
    \item Il bottone per la navbar è in alto a destra;
    \item Il logo della piattaforma in alto a sinistra;
    \item I bottoni, testi e form devono avere lo stesso stile e colore in base alla loro funzionalità;
    \item Lo stile del piatto in modalità dettaglio in menù e nella lista degli ordini personali è la stessa;
    \item Tutti le maschere hanno una visuale che utilizza la card.
\end{itemize}
\begin{figure}[H]
    \centering
    \includegraphics[scale=1]{figma.png}
    \caption{Figma SushiLab}
\end{figure}
\subsection{Progettazione API}
Durante il periodo di stage non era ancora presente il \gls{backendg} per l'applicativo, quindi si è deciso con l'azienda di progettare dei mock API per il testing utilizzando la piattaforma Stoplight.\\
La progettazione delle API sono molto semplici grazie all'interfaccia semplice di Stoplight, che permette di definire i path e i rispettivi metodi facilmente, e ai mock-up delle viste prima definite.\\
Per ogni chiamata \gls{restg} bisogna definire:
\begin{itemize}
    \item \textbf{Nome:} individua API;
    \item \textbf{Descrizione:} spiega in dettaglio la funzione della API;
    \item \textbf{Metodo:} definisce il tipo di chiamata, è stato usato:
    \begin{itemize}
        \item  \textbf{get:} per richiedere dei dati al server come la chiamata per ottenere il menù;
        \item  \textbf{post:} per inviare dei dati sintetici al server come i dati per login;
        \item  \textbf{delete:} per eliminare dei dati dal server come eliminazione della sessione di tavolo.
    \end{itemize}
    \item \textbf{Path:} definisce il percorso finale della API;
    \item \textbf{Risposta:} configura la risposta che ritorna la API, è stato usato:
    \begin{itemize}
        \item  \textbf{200:} richiesta andata a buon fine;
        \item  \textbf{201:} creazione andata a buon fine;
        \item  \textbf{204:} richiesta andata a buon fine ma il contenuto è vuoto;
        \item  \textbf{401:} non autorizzato;
        \item  \textbf{404:} non trovato;
        \item  \textbf{406:} non accettato;
        \item  \textbf{500:} errore interno.
    \end{itemize}
\end{itemize}
\begin{figure}[H]
    \centering
    \includegraphics[scale=0.55]{stoplight.png}
    \caption{Stoplight SushiLab}
\end{figure}

\subsection{Progettazione dei componenti}
I componenti sono stati individuati tramite l'analisi dei requisiti e la progettazione delle viste. Ogni componente ha delle funzionalità specifiche e tutti assieme costruisce la web-app che copre tutti i requisiti richiesti.
\\
% {\hyperref[cap:menu.component]{Il secondo capitolo}}
\section{Codifica}
\subsection{Interfaccie}
Dopo aver progettato i mock della visuale tramite figma e le API tramite stoplight si è iniziato la fase di codifica delle interfacce. La creazione dei template di default dei componenti è stato molto rapido grazie al command-line interface di Angular, utilizzando il comando 'ng generate component "nome del componente"' viene creato una cartella in cui contiene tutti i file che servono per il rendering del componente. Dopo la creazione dei file principali si parte a modificare il component.ts, che rapprensenta la logica del componente, vengono inseriti tutte le funzionalità che il componente deve avere. Una volta definito le funzionalità si inizia a modificare la struttura quindi il component.html. Infine si cambia lo stile del componente tramite il component.css.
Tutte le interfacce, con le loro funzionalità, descrizione dettagliata e visualizzazione grafica potranno essere reperiti nell'appendice {\hyperref[cap:appendice c]{C}}.
\subsubsection{Componenti service}
Per comunicare tra i vari componenti viene utilizzati i file service, per ogni tipologia di servizio si crea un file.service, sempre utilizzando il command-line di Angular. I servizi utilizzati sono:
\begin{itemize}
    \item auth.service: utilizzato per gestire le autenticazioni;
    \item menu.service: utilizzato per gestire tutte le funzionalità del menù;
    \item ordini.service: utilizzato per gestire le ordinazioni;
    \item tavolo.service: utilizzato per gestire le sessioni di tavolo;
    \item user.service: utilizzato per gestire le funzionalità dell'area personale.
\end{itemize}
\subsubsection{Componenti guard}
Arrivato alla fine della codifica si definiscono i componenti guard, che permettono d'intercettare la navigazione su un determinato componente e consertirne o meno l'accesso. Le regole di guard vengono definite dentro al metodo canActivate che ritorna un valore booleano, in base a questo valore garantisce l'accesso all'utente.